set.seed(100)
n <-10^4 # Tamaño de la muestra
X <- rnorm(n, mean = 5, sd = 5)
X <- rnorm(n, mean = 5, sd = 25)
X <- rnorm(n, mean = 5, sd = 25)
X
# Creamos una nueva ventana de gráficos
par(mfrow = c(1, 1))  # Una fila y una columna en la ventana de gráficos
# Graficamos X y A en el mismo gráfico de dispersión
plot(X, col = "blue", pch = 16, main = "Gráfico de dispersión de X y A", xlab = "X", ylab = "A")
points(A, col = "red", pch = 16)
# Agregamos una leyenda
legend("topright", legend = c("X", "A"), col = c("blue", "red"), pch = 16)
g<-Vectorize(function(x) (exp(-((x)^(2))))/(sqrt(2*pi))/(exp(-x - 5)))
A <- rexp(n) - 5
# Creamos una nueva ventana de gráficos
par(mfrow = c(1, 1))  # Una fila y una columna en la ventana de gráficos
# Graficamos X y A en el mismo gráfico de dispersión
plot(X, col = "blue", pch = 16, main = "Gráfico de dispersión de X y A", xlab = "X", ylab = "A")
points(A, col = "red", pch = 16)
# Agregamos una leyenda
legend("topright", legend = c("X", "A"), col = c("blue", "red"), pch = 16)
g<-Vectorize(function(x) (exp(-((x)^(2))))/(sqrt(2*pi))/(exp(-x - 5)))
set.seed(1410) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n, min = 1.9, max = 2.1) # genera un vector con distribución uniforme
g <-Vectorize(function(x) log(x)) # construimos función g
curve(g,1.8,2.2,col="blue",lwd=1,main="Grafico de g(X)")
grid()
set.seed(1410) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n, min = 1.9, max = 2.1) # genera un vector con distribución uniforme
g <-Vectorize(function(x) log(x)) # construimos función g
curve(g,1.8,2.2,col="blue",lwd=1,main="Grafico de g(X)")
grid()
Y <- g(U) #genera el vector para cada observación
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
P_est1=mean(Y)
e1<-(abs(P_est1-log(2)))
set.seed(1410) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n) # genera un vector con distribución uniforme
g <-Vectorize(function(x) (log(x +1)/2) +(1/2) ) # construimos función g
curve(g,0,1,col="blue",lwd=1,main="Grafico de g(X)")
grid()
Y <- g(U) #genera el vector para cada observación
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
P_est1=mean(Y)
e1<-(abs(P_est1-log(2)))
set.seed(1450) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n) # genera un vector con distribución uniforme
g <-Vectorize(function(x) (log(x +1)/2) +(1/2) ) # construimos función g
curve(g,0,1,col="blue",lwd=1,main="Grafico de g(X)")
grid()
Y <- g(U) #genera el vector para cada observación
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
P_est1=mean(Y)
e1<-(abs(P_est1-log(2)))
set.seed(1452) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n) # genera un vector con distribución uniforme
g <-Vectorize(function(x) (log(x + 1)/2) + (1/2) ) # construimos función g
curve(g,0,1,col="blue",lwd=1,main="Grafico de g(X)")
grid()
Y <- g(U) #genera el vector para cada observación
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
P_est1=mean(Y)
e1<-(abs(P_est1-log(2)))
set.seed(1457) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n) # genera un vector con distribución uniforme
g <-Vectorize(function(x) (log(x + 1)/2) + (1/2) ) # construimos función g
curve(g,0,1,col="blue",lwd=1,main="Grafico de g(X)")
grid()
Y <- g(U) #genera el vector para cada observación
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
P_est1=mean(Y)
e1<-(abs(P_est1-log(2)))
set.seed(147) # definimos una semilla
n <-10^4 # tamaño de la muestra
U <-runif(n) # genera un vector con distribución uniforme
g <-Vectorize(function(x) (log(x + 1)/2) + (1/2) ) # construimos función g
curve(g,0,1,col="blue",lwd=1,main="Grafico de g(X)")
grid()
Y <- g(U) #genera el vector para cada observación
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
P_est1=mean(Y)
e1<-(abs(P_est1-log(2)))
e1
set.seed(100) # establecemos una semilla
n <-10^4 # Tamaño de la muestra
X <- rnorm(n, mean = 5, sd = 25)
acumulado<-cumsum(Y)/(1:n)
plot(1:n,acumulado,col="blue",type="l",ylab="Aproximacion",xlab="Iteraciones")
abline(h=integrate(g,0,1)$value,col="red",lwd=1)
curve(rnorm(n,mean = 5, sd = 25),-0.1,1.1,lwd=1, ylim=c(-1,2))
curve(rnorm(x,mean = 5, sd = 25),-0.1,1.1,lwd=1, ylim=c(-1,2))
x <- rnorm(n, mean = 5, sd = 25)
curve(rnorm(x,mean = 5, sd = 25),-0.1,1.1,lwd=1, ylim=c(-1,2))
x <- rnorm(n, mean = 5, sd = 25)
curve(dnorm(x, mean = 5, sd = 25), -0.1, 1.1, lwd = 1, ylim = c(-1, 2))
x <- rnorm(n, mean = 5, sd = 25)
hist(x, xlim = c(-0.1, 1.1), col = "lightblue", border = "black")
curve(rnorm(x,mean = 5, sd = 25),-0.1,1.1,lwd=1, ylim=c(-1,2))
curve(rnorm(x,mean = 5, sd = 25),-0.1,1.1,lwd=1, ylim=c(-5,5))
curve(rnorm(x,mean = 5, sd = 25),-0.5,1.1,lwd=1, ylim=c(-5,5))
curve(rnorm(x,mean = 5, sd = 25),-0.5,1.1,lwd=1, ylim=c(-25,25))
pi
set.seed(452)
n <-10^4 # Tamaño de la muestra
U <- runif(n,0,2/11)
g <- Vectorize(function(x) ((1/pi) * exp(-((2-x)/2x)-0.5)^2))
g <- Vectorize(function(x) ((1/pi) * exp(-((2-x)/2x))-0.5)^2)))
curve(fPI(x), from=-5,to=9, main="Distribucion de Z",xlab="x",ylab="f(x)")
# Inciso 6 ---------------------------------------------------------------------
mu <- 4
sigma <- 4
mu_z <- 4-(4/2)
sigma_z <- 4+(4/4) #En realidad es sigma^2
fPI = function(x)
{
fx = exp( -((x - mu_z)^2/(2*(sigma_z))))/(sqrt(2*pi*sigma_z))
return(fx)
}
curve(fPI(x), from=-5,to=9, main="Distribucion de Z",xlab="x",ylab="f(x)")
abline(v = 4, lty = 3)
abline(v = 2, lty = 3)
#Usaremos dist cauchy para el proceso de markov
fpK = function(x,y){
pK = dcauchy(y,location = x) #x es el centro del pico de la distribución.
return(pK)
}
#Aplicando el algoritmo
N = 10^5 # Número de Iteraciones
L = 1000 # periodo quemado (burn in)
MCMC = matrix(data = 0, nrow = N, ncol = 12)
colnames(MCMC) =
c("x","y","PIx","PIy","Kxy","Kyx","Rxy","Ryx","Mxy","Myx","Fxy","Salto")
# 1. Inicial con un valor arbitrario de x del dominio de distribución
x = runif(1,-50,50)
for (i in 1:N){
# 2. Generamos la propuesta con una distribucion arbitraria
y = rcauchy(1,location = x) #Valor aleatorio según X
#3. Tasa de Aceptación
PIx = fPI(x)
PIy = fPI(y)
Kxy = fpK(x,y)
Kyx = fpK(y,x)
Rxy = (PIy*Kyx) / (PIx*Kxy)
Ryx = (PIx*Kxy) / (PIy*Kyx)
# Matriz estocástica de los estados de la distribución estacionaria
if (x!=y){
Mxy = Kxy*min(1,Rxy)
Myx = Kyx*min(1,Ryx)
}
else
{ Mxy = -1
Myx = -1
}
#4. Criterio de Aceptacion o Rechazo
#Probabilidad de aceptación,runif(1)
Fxy = runif(1)
MCMC[i,] = c(x,y,PIx,PIy,Kxy,Kyx,Rxy,Ryx,Mxy,Myx,Fxy,0)
if (Fxy < Rxy)
{x = y
lsalto = 1
}
else
{ lsalto = 0
}
MCMC[i,12] = lsalto
}
mcmc = MCMC[(L+1):N,"x"]
head(mcmc,50)
mean
media
media=mean(mcmc)
media
curve(fPI(x), from=-5,to=9, type="l",main="distribucion de Z",xlab="x",ylab="distribucion", lwd=3)
abline(v=mu, col='blue', lwd=3)
abline(v=mu/2, col='red', lwd=3)
abline(v=media, col='violet', lwd=3)
hist(mcmc,
freq = FALSE,
main = "Distribucion de muestra MCMC",
xlab = "x",
ylab = "distribucion(x)",
breaks = 200)
hist(mcmc,
freq = FALSE,
main = "Distribucion de muestra MCMC",
xlab = "x",
ylab = "distribucion(x)",
breaks = 200)
abline(v=mu, col='blue', lwd=3)
abline(v=mu/2, col='red', lwd=3)
abline(v=media, col='violet', lwd=3)
#Traceplot
plot(mcmc,type="l",xlab = "x", ylab = "y", main = "Traceplot de muestra MCMC")
abline(h=mu, col='blue', lwd=3)
abline(h=mu/2, col='red', lwd=3)
abline(h=media, col='violet', lwd=3)
media=mean(mcmc)
curve(fPI(x), from=-5,to=9, type="l",main="distribucion de Z",xlab="x",ylab="distribucion", lwd=3)
abline(v=mu, col='blue', lwd=3)
abline(v=mu/2, col='red', lwd=3)
abline(v=media, col='violet', lwd=3)
hist(mcmc,
freq = FALSE,
main = "Distribucion de muestra MCMC",
xlab = "x",
ylab = "distribucion(x)",
breaks = 200)
abline(v=mu, col='blue', lwd=3)
abline(v=mu/2, col='red', lwd=3)
#Mostrando resultados
par(mfrow=c(2,2))
media=mean(mcmc)
curve(fPI(x), from=-5,to=9, type="l",main="distribucion de Z",xlab="x",ylab="distribucion", lwd=3)
#Mostrando resultados
par(mfrow=c(1,1))
media=mean(mcmc)
curve(fPI(x), from=-5,to=9, type="l",main="distribucion de Z",xlab="x",ylab="distribucion", lwd=3)
abline(v=mu, col='blue', lwd=3)
abline(v=mu/2, col='red', lwd=3)
